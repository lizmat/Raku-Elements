=begin pod

=head1 NAME

Raku::Elements - The Elements of the Raku Programming Language

=head1 SYNOPSIS

=begin code :lang<raku>

use Raku::Elements;

=end code

=head1 DESCRIPTION

The C<Raku::Elements> distribution attempts to provide a programmatical
interface to an alternate description of the Raku Programming Language,
inspired by the "Periodic Table of the Operators" by I<Mark Lentczner>.

It basically provides an (incomplete) overview of the features of the
Raku Programming Language, sorted into groups in a way similar to the
"Periodic Table of Elements".

Please note that this is still very much a work in progress: a lot
of explanatory texts still need to be added.  Pull requests are B<very>
welcome!

=head1 ELEMENTS

=comment Generated on 2025-11-08T20:54:56+01:00 by make-rakudoc.raku
=comment PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE

L<C<Addenoid>|#Addenoid>
L<C<Bindoid>|#Bindoid>
L<C<Buildoid>|#Buildoid>
L<C<Complementary>|#Complementary>
L<C<Declaroid>|#Declaroid>
L<C<Differentoid>|#Differentoid>
L<C<Equalish>|#Equalish>
L<C<Expansive>|#Expansive>
L<C<Feedoid>|#Feedoid>
L<C<Flippant>|#Flippant>
L<C<Hyperoid>|#Hyperoid>
L<C<IOoid>|#IOoid>
L<C<Incremental>|#Incremental>
L<C<Junctive>|#Junctive>
L<C<Mathematicals>|#Mathematicals>
L<C<Metaoid>|#Metaoid>
L<C<Methodic>|#Methodic>
L<C<Multiplicoid>|#Multiplicoid>
L<C<Orderoid>|#Orderoid>
L<C<Quantoid>|#Quantoid>
L<C<Rangoid>|#Rangoid>
L<C<Reductoid>|#Reductoid>
L<C<Replicant>|#Replicant>
L<C<Rolific>|#Rolific>
L<C<Sequoid>|#Sequoid>
L<C<Shortoid>|#Shortoid>
L<C<Stuboid>|#Stuboid>
L<C<Talkoid>|#Talkoid>
L<C<Termic>|#Termic>
L<C<Throwoid>|#Throwoid>
L<C<Timeoid>|#Timeoid>
L<C<Topicoid>|#Topicoid>

=head2 Addenoid

The Addenoid group contains all infix operators that could be considered
doing addition or substraction functions.

=head3 CÂ«+Â» numeric add
=item tags: infix

=head3 CÂ«-Â» numeric subtract
=item alternates: CÂ«âˆ’Â»
=item tags: infix

=head3 CÂ«~Â» string concatenation
=item tags: infix

=head3 CÂ«+&Â» integer AND
=item tags: infix

=head3 CÂ«+|Â» integer OR
=item tags: infix

=head3 CÂ«+^Â» integer XOR
=item tags: infix

=head3 CÂ«~&Â» string AND
=item tags: infix

=head3 CÂ«~|Â» string OR
=item tags: infix

=head3 CÂ«~^Â» string XOR
=item tags: infix

=head3 CÂ«?&Â» boolean AND
=item tags: infix

=head3 CÂ«?|Â» boolean OR
=item tags: infix

=head3 CÂ«?^Â» boolean XOR
=item tags: infix

=head2 Bindoid



=head3 CÂ«=Â» bind right value in left container
=item tags: infix macro

=head3 CÂ«:=Â» bind right value to left lexpad entry
=item tags: infix macro

=head2 Buildoid



=head3 CÂ«=>Â» Pair constructor, named argument specification
=item tags: infix

=head3 CÂ«,Â» List constructor
=item tags: infix

=head3 CÂ«[ ]Â» Array constructor
=item tags: circumfix

=head3 CÂ«{ }Â» Hash constructor
=item tags: circumfix

=head3 CÂ«:{ }Â» Object Hash constructor
=item tags: circumfix

=head3 CÂ«' 'Â» literal string constructor
=item tags: syntax

=head3 CÂ«" "Â» literal string constructor with interpolation
=item tags: syntax

=head3 CÂ«< >Â» literal word list constructor
=item tags: syntax

=head3 CÂ«<< >>Â» literal word list constructor with interpolation
=item alternates: C<Â« Â»>
=item tags: syntax

=head3 CÂ«$( )Â» turn argument(s) into an item
=item tags: syntax

=head3 CÂ«itemÂ» turn argument(s) into an item
=item tags: sub method

=head3 CÂ«@( )Â» turn argument(s) into a list
=item tags: syntax

=head3 CÂ«listÂ» turn argument(s) into a list
=item tags: sub method

=head3 CÂ«%( )Â» turn argument(s) into a hash
=item tags: syntax

=head3 CÂ«hashÂ» turn argument(s) into a hash
=item tags: sub method

=head2 Complementary



=head3 CÂ«+Â» numerify
=item tags: prefix

=head3 CÂ«+^Â» numeric complement
=item tags: prefix

=head3 CÂ«-Â» numeric negation
=item alternates: CÂ«âˆ’Â»
=item tags: prefix

=head3 CÂ«^Â» numeric from zero upto
=item tags: prefix

=head3 CÂ«~Â» stringify
=item tags: prefix

=head3 CÂ«?Â» boolify
=item tags: prefix

=head3 CÂ«soÂ» low precedence boolify
=item tags: prefix

=head3 CÂ«!Â» boolean negation
=item alternates: CÂ«?^Â»
=item tags: prefix

=head3 CÂ«notÂ» low precedence boolean negation
=item tags: prefix

=head3 CÂ«//Â» is defined
=item tags: prefix

=head3 L<CÂ«|Â» flatten args, slip iterable|https://docs.raku.org/syntax/%7C>
=item tags: prefix

The meaning of prefix `|` was expanded in 6.c to be beyond the use within
signatures, to mean converting any iterable to a `Slip` (a special type of
`list` that will always be iterated).


=head3 CÂ«âš›Â» atomic integer access
=item tags: prefix

=head2 Declaroid



=head3 CÂ«myÂ» define something in MY:: scope
=item tags: syntax

=head3 CÂ«ourÂ» define something in OUR:: scope
=item tags: syntax

=head3 CÂ«anonÂ» define something without storing it in a scope
=item tags: syntax

=head2 Differentoid



=head3 CÂ«beforeÂ» generic less
=item tags: infix

=head3 CÂ«<Â» numerically less
=item tags: infix

=head3 CÂ«ltÂ» alphabetically less
=item tags: infix

=head3 CÂ«<=Â» numerically less or equal
=item alternates: CÂ«â‰¤Â»
=item tags: infix

=head3 CÂ«leÂ» alphabetically less or equal
=item tags: infix

=head3 CÂ«!=Â» numeric inequality
=item alternates: CÂ«â‰ Â»
=item tags: infix

=head3 CÂ«neÂ» string inequality
=item tags: infix

=head3 CÂ«>=Â» numerically more or equal
=item tags: infix

=head3 CÂ«geÂ» alphabetically more or equal
=item tags: infix

=head3 CÂ«>Â» numerically more
=item tags: infix

=head3 CÂ«gtÂ» alphabetically more
=item tags: infix

=head3 CÂ«afterÂ» generic more
=item tags: infix

=head3 CÂ«!(elem)Â» is not element in
=item alternates: CÂ«âˆ‰Â»
=item tags: infix

=head3 CÂ«!(cont)Â» does not contain element
=item alternates: CÂ«âˆŒÂ»
=item tags: infix

=head3 CÂ«!(<)Â» is not a strict quanthash subset
=item alternates: CÂ«âŠ„Â»
=item tags: infix

=head3 CÂ«!(<=)Â» is not a quanthash subset
=item alternates: CÂ«âŠˆÂ»
=item tags: infix

=head3 CÂ«!(==)Â» quanthash inequality
=item alternates: CÂ«â‰¢Â»
=item tags: infix

=head3 CÂ«!(>=)Â» is not a quanthash superset
=item alternates: CÂ«âŠ‰Â»
=item tags: infix

=head3 CÂ«!(>)Â» is not a strict quanthash superset
=item alternates: CÂ«âŠ…Â»
=item tags: infix

=head2 Equalish



=head3 CÂ«~~Â» smart match
=item tags: infix

=head3 CÂ«eqvÂ» canonical equivalence
=item tags: infix

=head3 CÂ«eqÂ» string equality
=item tags: infix

=head3 CÂ«==Â» numeric equality
=item tags: infix

=head3 CÂ«=~=Â» numeric almost equal
=item alternates: CÂ«â‰…Â»
=item tags: infix

=head3 CÂ«===Â» value identity
=item tags: infix

=head3 CÂ«=:=Â» value identity without decontainerization
=item tags: infix

=head3 CÂ«(elem)Â» is element in
=item alternates: CÂ«âˆˆÂ»
=item tags: infix

=head3 CÂ«(cont)Â» contains element
=item alternates: CÂ«âˆ‹Â»
=item tags: infix

=head3 CÂ«(<)Â» is strict quanthash subset
=item alternates: CÂ«âŠ‚Â»
=item tags: infix

=head3 CÂ«(<=)Â» is quanthash subset
=item alternates: CÂ«âŠ†Â»
=item tags: infix

=head3 CÂ«(==)Â» quanthash equality
=item alternates: CÂ«â‰¡Â»
=item tags: infix

=head3 CÂ«(>=)Â» is quanthash superset
=item alternates: CÂ«âŠ‡Â»
=item tags: infix

=head3 CÂ«(>)Â» is strict quanthash superset
=item alternates: CÂ«âŠƒÂ»
=item tags: infix

=head2 Expansive



=head3 CÂ«iÂ» the imaginary unit
=item tags: postfix

=head3 L<CÂ«â¿Â» integer literal exponentiation|https://docs.raku.org/routine/%2A%2A>
=item tags: postfix

So `$aÂ²` is the same as `$a ** 2`, etc.  Any of `â°Â¹Â²Â³â´âµâ¶â·â¸â¹âºÂ¯Â¯` may be used.


=head2 Feedoid



=head3 CÂ«==>Â» feed left to right
=item tags: infix

=head3 CÂ«<==Â» feed right to left
=item tags: infix

=head2 Flippant



=head3 CÂ«?? !!Â» ternary logic
=item tags: syntax

=head3 CÂ«ffÂ» flip-flop inclusive
=item tags: infix macro

=head3 CÂ«^ffÂ» flip-flop excluding start
=item tags: infix macro

=head3 CÂ«ff^Â» flip-flop excluding end
=item tags: infix macro

=head3 CÂ«^ff^Â» flip-flop exclusive
=item tags: infix macro

=head3 CÂ«fffÂ» sed-like flip-flop inclusive
=item tags: infix macro

=head3 CÂ«^fffÂ» sed-like flip-flop excluding start
=item tags: infix macro

=head3 CÂ«fff^Â» sed-like flip-flop excluding end
=item tags: infix macro

=head3 CÂ«^fff^Â» sed-like flip-flop exclusive
=item tags: infix macro

=head2 Hyperoid



=head3 CÂ«>>op<<Â» produce operator results for equal lists
=item alternates: C<Â»opÂ« >
=item tags: infix syntax

=head3 CÂ«>>op>>Â» produce operator results, left side leading
=item alternates: C<Â»opÂ»>
=item tags: infix syntax

=head3 CÂ«<<op<<Â» produce operator results, right side leading
=item alternates: C<Â«opÂ«>
=item tags: infix syntax

=head3 CÂ«<<op>>Â» produce operator results, longest side leading
=item alternates: C<Â«opÂ»>
=item tags: infix syntax

=head3 L<CÂ«ZopÂ» produce operator result, shortest side leading|Default for `op` is `,`>
=item tags: infix syntax

=head3 L<CÂ«XopÂ» produce operator result for combinations|Default for `op` is `,`>
=item tags: infix syntax

=head2 IOoid



=head3 CÂ«getÂ» Read a line from C<$*STDIN> / C<$*ARGFILES>
=item tags: sub method

=head3 CÂ«getcÂ» Read a character from C<$*STDIN> / C<$*ARGFILES>
=item tags: sub method

=head3 CÂ«readÂ» Read bytes from IO::Handle
=item tags: method

=head3 CÂ«writeÂ» Write bytes to IO::Handle
=item tags: method

=head3 CÂ«slurpÂ» Read entire contents of IO::Path / IO::Handle
=item tags: sub method

=head3 CÂ«spurtÂ» Replace content of IO::Path / IO::Handle with argument
=item tags: sub method

=head2 Incremental

The atomic versions of -- and ++ were implemented for 6.d.  They can only
be applied to atomic integers.

=head3 CÂ«++Â» pre-increment by 1
=item tags: prefix

=head3 CÂ«âš›++Â» atomic pre-increment by 1
=item tags: prefix

=head3 CÂ«--Â» pre-decrement by 1
=item tags: prefix

=head3 CÂ«âš›--Â» atomic pre-decrement by 1
=item tags: prefix

=head3 CÂ«++Â» post-increment by 1
=item tags: postfix

=head3 CÂ«âš›++Â» atomic post-increment by 1
=item tags: postfix

=head3 CÂ«--Â» post-decrement by 1
=item tags: postfix

=head3 CÂ«âš›--Â» atomic post-decrement by 1
=item tags: postfix

=head2 Junctive



=head3 CÂ«&Â» junctive all
=item tags: infix

=head3 CÂ«|Â» junctive any
=item tags: infix

=head3 CÂ«^Â» junctive one
=item tags: infix

=head3 CÂ«allÂ» junctive all
=item tags: sub method

=head3 CÂ«anyÂ» junctive any
=item tags: sub method

=head3 CÂ«oneÂ» junctive one
=item tags: sub method

=head3 CÂ«noneÂ» junctive none
=item tags: sub method

=head2 Mathematicals



=head3 CÂ«piÂ» The number Ï€ (3.1415...)
=item alternates: CÂ«Ï€Â»
=item tags: term

=head3 CÂ«tauÂ» The number Ï„ (6.2831...)
=item alternates: CÂ«Ï„Â»
=item tags: term

=head3 CÂ«eÂ» Euler's number (2.7182...)
=item alternates: CÂ«ğ‘’Â»
=item tags: term

=head3 CÂ«iÂ» The imaginary unit (sqrt(-1))
=item tags: term

=head3 CÂ«InfÂ» Infinity
=item alternates: CÂ«âˆÂ»
=item tags: term

=head2 Metaoid



=head3 CÂ«op=Â» store result of operator on left/right on left side
=item tags: infix syntax

=head3 CÂ«RopÂ» produce result of operator with arguments reversed
=item tags: infix syntax

=head3 CÂ«!opÂ» negate result of iffy operator on arguments
=item tags: index syntax

=head2 Methodic

Dotted postfix operators must be followed by a method name or a subroutine
name prefixed with `&` (possibly fully qualified), a postfix operator, a
prefix operator within `:<>`, or one of the postcircumfixes `( )` `[ ]`
`{ }` `< >` `Â« Â»`.

=head3 CÂ«.methodÂ» method call
=item tags: postfix

=head3 CÂ«. methodÂ» dotty infix method call
=item tags: infix

=head3 CÂ«.^methodÂ» meta-method call
=item tags: postfix

=head3 CÂ«.?methodÂ» call method if any
=item tags: postfix

=head3 CÂ«.*methodÂ» call all methods if any
=item tags: postfix

=head3 CÂ«.+methodÂ» call all methods
=item tags: postfix

=head3 CÂ«!methodÂ» private method call
=item tags: postfix

=head3 CÂ«.=methodÂ» incovant mutating method call
=item tags: postfix

=head2 Multiplicoid



=head3 CÂ«divÂ» integer divide
=item tags: infix

=head3 CÂ«modÂ» integer modulus
=item tags: infix

=head3 CÂ«gcdÂ» greatest common divisor
=item tags: infix

=head3 CÂ«lcmÂ» lowest common multiple
=item tags: infix

=head3 CÂ«*Â» multiply
=item alternates: CÂ«Ã—Â»
=item tags: infix

=head3 CÂ«/Â» divide
=item alternates: CÂ«Ã·Â»
=item tags: infix

=head3 CÂ«**Â» exponentiation
=item tags: infix

=head3 CÂ«%Â» modulus
=item tags: infix

=head3 CÂ«%%Â» is divisible
=item tags: infix

=head3 CÂ«+<Â» integer shift left
=item tags: infix

=head3 CÂ«+>Â» integer shift right
=item tags: infix

=head2 Orderoid

Return an `Order` enum

=head3 CÂ«cmpÂ» equivalence order comparison
=item tags: infix

=head3 CÂ«<=>Â» numerical order comparison
=item tags: infix

=head3 CÂ«legÂ» string order comparison
=item tags: infix

=head2 Quantoid



=head3 CÂ«âˆ…Â» empty Set
=item tags: term

=head3 CÂ«(|)Â» quanthash union
=item alternates: CÂ«âˆªÂ»
=item tags: infix

=head3 CÂ«(+)Â» quanthash addition
=item alternates: CÂ«âŠÂ»
=item tags: infix

=head3 CÂ«(.)Â» quanthash multiplication
=item alternates: CÂ«âŠÂ»
=item tags: infix

=head3 CÂ«(-)Â» quanthash difference
=item alternates: CÂ«âˆ–Â»
=item tags: infix

=head3 CÂ«(^)Â» quanthash symmetric difference
=item alternates: CÂ«âŠ–Â»
=item tags: infix

=head2 Rangoid



=head3 CÂ«..Â» range inclusive
=item tags: infix

=head3 CÂ«^..Â» range excluding start
=item tags: infix

=head3 CÂ«..^Â» range excluding end
=item tags: infix

=head3 CÂ«^..^Â» range exclusive
=item tags: infix

=head3 CÂ«minmaxÂ» range including min and max value
=item tags: infix

=head2 Reductoid



=head3 CÂ«minmaxÂ» reduce values to Range of min and max value
=item tags: infix sub method

=head3 CÂ«minÂ» reduce values to smallest value
=item tags: infix sub method

=head3 CÂ«maxÂ» reduce values to largest value
=item tags: infix sub method

=head3 CÂ«[op]Â» reduce using given infix operator
=item tags: prefix syntax

=head3 CÂ«[\op]Â» produce steps of reduction using given infix operator
=item tags: prefix syntax

=head2 Replicant



=head3 CÂ«xÂ» string repetition
=item tags: infix

=head3 CÂ«xxÂ» item repetition
=item tags: infix

=head2 Rolific



=head3 CÂ«doesÂ» mutating role mixin
=item tags: infix

=head3 CÂ«butÂ» cloning role mixin
=item tags: infix

=head2 Sequoid



=head3 CÂ«...Â» smart sequence inclusive
=item tags: infix

=head3 CÂ«^...Â» smart sequence excluding start
=item tags: infix

=head3 CÂ«...^Â» smart sequence excluding end
=item tags: infix

=head3 CÂ«^...^Â» smart sequence exclusive
=item tags: infix

=head2 Shortoid



=head3 CÂ«&&Â» high precedence logical AND
=item tags: infix macro

=head3 CÂ«andÂ» low precedence logical AND
=item tags: infix macro

=head3 CÂ«||Â» high precedence logical OR
=item tags: infix macro

=head3 CÂ«orÂ» low precedence logical OR
=item tags: infix macro

=head3 CÂ«^^Â» high precedence logical XOR
=item tags: infix macro

=head3 CÂ«xorÂ» low precedence logical XOR
=item tags: infix macro

=head3 CÂ«//Â» high precedence is defined OR
=item tags: infix macro

=head3 CÂ«notandthenÂ» Empty if first defined, else last
=item tags: infix macro

=head2 Stuboid



=head3 CÂ«???Â» warn about stub code executed
=item tags: term macro

=head3 CÂ«...Â» fail with stub code executed error
=item tags: term macro

=head3 CÂ«!!!Â» die with stub code executed error
=item tags: term macro

=head2 Talkoid



=head3 CÂ«printÂ» stringify argument(s), write to C<$*STDOUT>
=item tags: sub method

=head3 CÂ«sayÂ» create gist of argument(s), add newline, write to C<$*STDOUT>
=item tags: sub method

=head3 CÂ«putÂ» stringify argument(s), add newline, write to C<$*STDOUT>
=item tags: sub method

=head3 CÂ«noteÂ» create gist of argument(s), add newline, write to C<$*STDERR>
=item tags: sub method

=head2 Termic



=head3 CÂ«selfÂ» invocant in method
=item tags: term

=head3 CÂ«randÂ» pseudo-random Num in range 
=item tags: term

=head2 Throwoid



=head3 CÂ«dieÂ» halt execution, or be caught by CATCH
=item tags: sub

=head3 CÂ«warnÂ» show error message, or be caught by CONTROL
=item tags: sub

=head3 CÂ«failÂ» return from Routine with Failure, or be caught by CATCH
=item tags: sub

=head3 CÂ«returnÂ» return from Routine with given value, or be caught by CONTROL
=item tags: sub method

=head3 CÂ«nextÂ» proceed with next iteration, or be caught by CONTROL
=item tags: sub

=head3 CÂ«redoÂ» restart current iteration, or be caught by CONTROL
=item tags: sub

=head3 CÂ«lastÂ» stop iterating, or be caught by CONTROL
=item tags: sub

=head3 CÂ«proceedÂ» continue with next when/default, or be caught by CONTROL
=item tags: sub

=head3 CÂ«succeedÂ» continue after last when/default, or be caught by CONTROL
=item tags: sub

=head3 CÂ«doneÂ» call "done" callback on taps, or be caught by CONTROL
=item tags: sub

=head3 CÂ«emitÂ» emit given value to active supply, or be caught by CONTROL
=item tags: sub method

=head2 Timeoid



=head3 CÂ«nowÂ» Instant of current time
=item tags: term

=head3 CÂ«timeÂ» POSIX time in seconds
=item tags: term

=head3 CÂ«nanoÂ» POSIX time in nano seconds
=item tags: term

=head2 Topicoid



=head3 CÂ«givenÂ» topicalize argument for scope
=item tags: syntax

=head3 CÂ«whenÂ» if smartmatched topicalize argument for scope
=item tags: syntax

=head3 CÂ«andthenÂ» topicalize left for right thunk
=item tags: infix thunky

=head3 CÂ«orelseÂ» low precedence if defined OR, topicalizing left for right thunk
=item tags: infix thunky

=comment PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE

=head1 CLASSES

=head2 Raku::Elements

The programmatical interface to the elements of the Raku Programming
Language.

=head3 elements

A C<Map> with the elements of the Raku Programming Language.  The key
represents either the name of an C<Raku::Element>, or one of its
alternates.  The value is a C<List> of one or more C<Raku::Element>
objects that share the same name (but may have different tags).

=head3 groups

A C<Map> with C<Raku::Group> object, keyed to their name.

=head2 Raku::Group

The information about an element group.

=head3 name

The name of the element group.

=head3 description

The description of the element group (if any)

=head3 elements

A list of C<Raku::Element> objects belonging to this group.

=head2 Raku::Element

=head3 name

The name of the element.  This may be non-alphabetic, specifically in
the case of operators such as C<+>.

=head3 alternates

Alternate names of the element, for instance an Unicode version versus
an ASCII version of an operator, such as C<âˆˆ> as al alternate name for
C<(elem)>.  Usually empty.

=head3 tags

A list of tags that apply to this element, e.g. C<infix> for an infix
operator.  Has at least one element.

=head3 tagline

The tagline of the element: a one-line description.

=head3 url

A URL for more information about this element.

=head3 description

A more general description of the element.  Optional.

=head1 AUTHOR

Elizabeth Mattijsen <liz@raku.rocks>

Source can be located at: https://github.com/lizmat/Raku-Elements .
Comments and Pull Requests are welcome.

If you like this module, or what Iâ€™m doing more generally, committing to a
L<small sponsorship|https://github.com/sponsors/lizmat/>  would mean a great
deal to me!

=head1 RESOURCE FILES

This distribution keeps all of the text files as resources, to be read when
they are needed (as opposed to keeping them all in the binary).

The C<resources> directory contains a C<groups> directory that contains all
of the information for each group in a separat file.

=head2 Group file format

The format of the group file is very simple line based.

All entries are separated by an empty line.  The first line contains the
names of the element separated by the string C< | > (space, pipe, space).
There must be at least one name.  The first name becomes the C<name> of
the element, the others become C<aliases>.

The second line contains theo tags as space separated words.  There must
be at least a single tag.

The third line contains the tagline of the element.

The fourth line (if not empty) contains the URL for more information,

Any other lines until an empty line, contains the description of the
element.

If the first line is empty, then the rest of the file contains the
description of the group (so you can recognize the description as the
text after the first 2 empty lines).  If there are no 2 empty lines,
then there is no description for the group.

=head1 COPYRIGHT AND LICENSE

Copyright 2025 Elizabeth Mattijsen

This library is free software; you can redistribute it and/or modify it under the Artistic License 2.0.

=end pod

# vim: expandtab shiftwidth=4
