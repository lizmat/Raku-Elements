=begin pod

=head1 NAME

Raku::Elements - The Elements of the Raku Programming Language

=head1 SYNOPSIS

=begin code :lang<raku>
use Raku::Elements;

my $info = Raku::Elements.new;
=end code

=head1 DESCRIPTION

The C<Raku::Elements> distribution attempts to provide a programmatical
interface to an alternate description of the Raku Programming Language,
inspired by the "Periodic Table of the Operators" by I<Mark Lentczner>.

It basically provides an (incomplete) overview of the features of the
Raku Programming Language, sorted into groups in a way similar to the
"Periodic Table of Elements".

Please note that this is still very much a work in progress: a lot
of explanatory texts still need to be added.  Pull requests are B<very>
welcome!

=head1 CLASSES

=head2 Raku::Elements

=begin code :lang<raku>
my $info = Raku::Elements.new;
=end code

The programmatical interface to the elements of the Raku Programming
Language.  Can be instantiated by calling C<.new>.  Provides these
methods:

=head3 elements

A C<Map> with the elements of the Raku Programming Language.  The key
represents either the name of an C<Raku::Element>, or one of its
alternates.  The value is a C<List> of one or more C<Raku::Element>
objects that share the same name (but may have different tags).

=head3 groups

A C<Map> with C<Raku::Group> objects, keyed to their name.

=head3 tags

A C<Map> with C<Raku::Tag> objects, keyed to their name.

=head2 Raku::Group

The information about an element group of the Raku Programming Language.
It is usually created automatically when a C<Raku::Elements> object is
instantiated.

=head3 name

The name of the element group.

=head3 description

The description of the element group (if any)

=head3 elements

A list of C<Raku::Element> objects belonging to this group.

=head2 Raku::Element

=head3 name

The name of the element.  This may be non-alphabetic, specifically in
the case of operators such as C<+>.

=head3 alternates

Alternate names of the element, for instance an Unicode version versus
an ASCII version of an operator, such as C<âˆˆ> as al alternate name for
C<(elem)>.  Usually empty.

=head3 tags

A list of tags that apply to this element, e.g. C<infix> for an infix
operator.  Has at least one element.

=head3 tagline

The tagline of the element: a one-line description.

=head3 url

A URL for more information about this element.

=head3 description

A more general description of the element.  Optional.

=head2 Raku::Tag

The information about an element tag of the Raku Programming Language.
It is usually created automatically when a C<Raku::Elements> object is
instantiated.

=head3 name

The name of the tag.

=head3 description

The description of the tag (if any)

=head3 elements

A list of C<Raku::Element> objects belonging that have this tag set.

=head1 ELEMENTS

This section of the documentation is generated from the information
supplied by the C<Raku::Elements> object.  It is provided here as an
example of what can be done with the information provided by this
distribution.

=comment PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE
=comment Generated on 2025-11-11T19:48:02+01:00 by ./make-rakudoc.raku

=head2 Raku Element Tags

L<C<boolean>|#boolean>
L<C<circumfix>|#circumfix>
L<C<hash>|#hash>
L<C<infix>|#infix>
L<C<integer>|#integer>
L<C<interrupt>|#interrupt>
L<C<junction>|#junction>
L<C<list>|#list>
L<C<macro>|#macro>
L<C<method>|#method>
L<C<numeric>|#numeric>
L<C<order>|#order>
L<C<pair>|#pair>
L<C<postfix>|#postfix>
L<C<prefix>|#prefix>
L<C<quanthash>|#quanthash>
L<C<range>|#range>
L<C<string>|#string>
L<C<sub>|#sub>
L<C<syntax>|#syntax>
L<C<term>|#term>
L<C<thunky>|#thunky>
L<C<topic>|#topic>

=head3 boolean

Produces a C<Bool> value: either C<True> or C<False>.

=head3 circumfix

Operators that consist of an opening and a closing tag, with their
arguments between them.

=head3 hash

Produces a C<Hash> object.

=head3 infix

Operators that typically take two values, one to the left and one to
the right of the operator.

=head3 integer

Produces an C<Int> value.

=head3 interrupt

Interrupts the normal flow of execution.

=head3 junction

Produces a C<Junction> object.

=head3 list

Produces a C<List> or C<Array> object.

=head3 macro

Syntax structures that may change the semantics of the code given
at compile time.

=head3 method

A C<Callable> with a name that takes an invocant as its first argument,
and which is typically part of a C<class>, C<role> or C<grammar>.

=head3 numeric

Produces a C<Numeric> value.

=head3 order

Produces an C<Order> value, as in C<Less>, C<Same> or C<More>.

=head3 pair

Produces a C<Pair> object.

=head3 postfix

An operator that is placed B<after> the argument it operates on.

=head3 prefix

An operator that is placed B<before> the argument it operates on.

=head3 quanthash

Produces a C<QuantHash> object, which is one of:
C<Set>, C<SetHash>, C<Bag>, C<BagHash>, C<Mix>, C<MixHash>.

=head3 range

Produces a C<Range> object.

=head3 string

Produces a C<Str> object.

=head3 sub

A C<Callable> with a name that can be returned from.

=head3 syntax

A syntax element of the Raku Programming Language that typically
doesn't have its own (visible) runtime component.

=head3 term

Elements of the Raku Programming Language that exists on their own and
which are known to not accept any arguments.

=head3 thunky

Having special syntax handling causing it to not immediately be executed
(like a C<Callable>) but without having an independent scope.

=head3 topic

Sets the topic variable (C<$_>).

=head2 Raku Element Groups

L<C<Addenoid>|#Addenoid>
L<C<Bindoid>|#Bindoid>
L<C<Buildoid>|#Buildoid>
L<C<Declaroid>|#Declaroid>
L<C<Differentoid>|#Differentoid>
L<C<Equalish>|#Equalish>
L<C<Expansive>|#Expansive>
L<C<Feedoid>|#Feedoid>
L<C<Flippant>|#Flippant>
L<C<Hyperoid>|#Hyperoid>
L<C<IOoid>|#IOoid>
L<C<Incremental>|#Incremental>
L<C<Junctive>|#Junctive>
L<C<Mathematicals>|#Mathematicals>
L<C<Metaoid>|#Metaoid>
L<C<Methodic>|#Methodic>
L<C<Mixoid>|#Mixoid>
L<C<Multiplicoid>|#Multiplicoid>
L<C<Normaloid>|#Normaloid>
L<C<Orderoid>|#Orderoid>
L<C<Quantoid>|#Quantoid>
L<C<Rangoid>|#Rangoid>
L<C<Reductoid>|#Reductoid>
L<C<Replicant>|#Replicant>
L<C<Sequoid>|#Sequoid>
L<C<Shortoid>|#Shortoid>
L<C<Stuboid>|#Stuboid>
L<C<Talkoid>|#Talkoid>
L<C<Termoid>|#Termoid>
L<C<Throwoid>|#Throwoid>
L<C<Topicoid>|#Topicoid>

=head2 Addenoid

The Addenoid group contains all infix operators that could be considered doing addition
or substraction functions.

=head3 L<CÂ«+Â» numeric add|https://docs.raku.org/language/operators#infix_+>
=item L<infix|#infix> L<numeric|#numeric>

Coerces either side to a C<Numeric> value, and then adds them.

=head3 L<CÂ«-Â» numeric subtract|https://docs.raku.org/language/operators#infix_->
=item alternates: CÂ«âˆ’Â»
=item L<infix|#infix> L<numeric|#numeric>

Coerces both sides to a C<Numeric> value, and then substracts the right
side from the left side.

=head3 L<CÂ«~Â» string concatenation|https://docs.raku.org/language/operators#infix_~>
=item L<infix|#infix> L<string|#string>

Coerces both sides to a C<Str>, and then concatenates them.

=head3 L<CÂ«+&Â» integer AND|https://docs.raku.org/language/operators#infix_+&>
=item L<infix|#infix> L<integer|#integer>

Coerces both sides to an C<Int> value, and then does a bitwise AND.

=head3 L<CÂ«+|Â» integer OR|https://docs.raku.org/language/operators#infix_+|>
=item L<infix|#infix> L<integer|#integer>

Coerces both sides to an C<Int> value, and then does a bitwise OR.

=head3 L<CÂ«+^Â» integer XOR|https://docs.raku.org/language/operators#infix_+^>
=item L<infix|#infix> L<integer|#integer>

Coerces both sides to an C<Int> value, and then does a bitwise XOR.

=head3 L<CÂ«~&Â» string AND|https://docs.raku.org/language/operators#infix_~&>
=item L<infix|#infix> L<string|#string>

Coerces both sides to a C<Buffer> value, and then does a bitwise AND
and converts the result back to a C<Str>.

=head3 L<CÂ«~|Â» string OR|https://docs.raku.org/language/operators#infix_~|>
=item L<infix|#infix> L<string|#string>

Coerces both sides to a C<Buffer> value, and then does a bitwise OR
and converts the result back to a C<Str>.

=head3 L<CÂ«~^Â» string XOR|https://docs.raku.org/language/operators#infix_~^>
=item L<infix|#infix> L<string|#string>

Coerces both sides to a C<Buffer> value, and then does a bitwise XOR
and converts the result back to a C<Str>.

=head3 L<CÂ«?&Â» boolean AND|https://docs.raku.org/language/operators#infix_?&>
=item L<infix|#infix> L<boolean|#boolean>

Coerces both sides to a C<Bool> value, and then does a logical AND.

=head3 L<CÂ«?|Â» boolean OR|https://docs.raku.org/language/operators#infix_?|>
=item L<infix|#infix> L<boolean|#boolean>

Coerces both sides to a C<Bool> value, and then does a logical OR.

=head3 L<CÂ«?^Â» boolean XOR|https://docs.raku.org/language/operators#infix_?^>
=item L<infix|#infix> L<boolean|#boolean>

Coerces both sides to a C<Bool> value, and then does a logical XOR.

=head2 Bindoid

The Bindoid group contains all macro-ish infix operators that perform raw binding,
possibly into a container (which would make it an assignment).

=head3 L<CÂ«=Â» assign value(s)|https://docs.raku.org/language/operators#infix_=_(item_assignment)>
=item L<infix|#infix> L<macro|#macro>

Performs an assignment.  The left side is supposed to be either a
C<Scalar>, a C<Positional> with C<Scalar> containers (typically an
C<Array> such as C<my @foo>), or an C<Associative> with C<Scalar>
containers (typically a C<Hash> such as C<my %bar>).
=begin code :lang<raku>
my $a   = 42;
my @foo = 1,2,3,4,5;
my %bar = a => 42, b => 666, c => 137;
=end code

=head3 L<CÂ«:=Â» bind right value to left lexpad entry|https://docs.raku.org/language/operators#infix_:=>
=item L<infix|#infix> L<macro|#macro>

Performs a binding operation on the lexpad entry on the left.  This
is generally done to indicate that it is an immutable value, or if
you want to alias one container to another.
=begin code :lang<raku>
my $b := 42;  # immutable
my $c  = 666;
my $d := $c;  # alias
$d = 137;
say $c;  # 137
=end code

=head2 Buildoid

The Buildoid group contains all elements that convert a given set of arguments into one of
a C<Scalar>, C<Pair>, C<Positional> or C<Associative> object.

=head3 L<CÂ«=>Â» C<Pair> constructor, named argument specification|https://docs.raku.org/language/operators#infix_=%3E>
=item L<infix|#infix> L<syntax|#syntax> L<pair|#pair>

Indicates a named argument inside a C<Capture> (for instance, as
argument to a subroutine call).  Otherwise it functions as a
C<Pair> constructor, with the left side being the key.
=begin code :lang<raku>
frobnicate(a => 42);  # named argument
my $p = foo => 42;    # Pair
=end code

=head3 L<CÂ«,Â» C<List> constructor|https://docs.raku.org/language/operators#infix_,>
=item L<infix|#infix> L<list|#list>

Places all of its arguments in a C<List>.  Note that parentheses
are B<not> needed for a list to be created.  The only exception
is the empty C<List>, which can be constructed by C<()>.

=head3 L<CÂ«[ ]Â» C<Array> constructor|https://docs.raku.org/language/operators#circumfix_[_]>
=item L<circumfix|#circumfix> L<list|#list>

Creates an C<Array> out of the given arguments, typically used
when assigning to a hash.
=begin code :lang<raku>
my %foo;
%foo<bar> = [1,2,3,4];
=end code

=head3 L<CÂ«{ }Â» C<Block> or C<Hash> constructor|https://docs.raku.org/language/operators#term_{_}>
=item L<circumfix|#circumfix> L<syntax|#syntax> L<hash|#hash>

Either creates a C<Block> object (if it looks like there is Raku code
between the brackets), or a C<Hash> built from its arguments (which
is usually done when assigning to another C<Hash> or C<Array>)..
=begin code :lang<raku>
my &hello = { say "hello world" }                 # code, so Block
hello;  # hello world
my @menu = { salad => 4.50 }, { steak => 22.50 }  # args, so Hash
say @menu[0]<salad>;  # 4.5
=end code

=head3 L<CÂ«:{ }Â» Object Hash constructor|https://docs.raku.org/language/hashmap#Non-string_keys_(object_hash)>
=item L<circumfix|#circumfix> L<hash|#hash>

=head3 L<CÂ«' 'Â» literal string constructor|https://docs.raku.org/language/101-basics#Double-quoted_strings_and_single-quoted_strings>
=item L<syntax|#syntax> L<string|#string>

=head3 L<CÂ«" "Â» literal string constructor with interpolation|https://docs.raku.org/language/101-basics#Double-quoted_strings_and_single-quoted_strings>
=item L<syntax|#syntax> L<string|#string>

=head3 L<CÂ«< >Â» literal word list constructor|https://docs.raku.org/language/operators#term_%3C_%3E>
=item L<syntax|#syntax> L<list|#list> L<string|#string>

=head3 L<CÂ«<< >>Â» literal word list constructor with interpolation|https://docs.raku.org/language/quoting#Word_quoting_with_interpolation_and_quote_protection:_Â«_Â»>
=item alternates: C<Â« Â»>
=item L<syntax|#syntax> L<list|#list> L<string|#string>

=head3 CÂ«$( )Â» turn argument(s) into an item
=item L<syntax|#syntax>

=head3 L<CÂ«itemÂ» turn argument(s) into an item|https://docs.raku.org/type/Mu#routine_item>
=item L<sub|#sub> L<method|#method>

=head3 CÂ«@( )Â» turn argument(s) into a list
=item L<syntax|#syntax> L<list|#list>

=head3 L<CÂ«listÂ» turn argument(s) into a list|https://docs.raku.org/type/List#routine_list>
=item L<sub|#sub> L<method|#method> L<list|#list>

=head3 CÂ«%( )Â» turn argument(s) into a hash
=item L<syntax|#syntax> L<hash|#hash>

=head3 L<CÂ«hashÂ» turn argument(s) into a hash|https://docs.raku.org/type/Any#method_hash>
=item L<sub|#sub> L<method|#method> L<hash|#hash>

=head2 Declaroid

The Declaroid group contains the syntax for indicating the scope of an element to be defined.

=head3 CÂ«myÂ» define something in MY:: scope
=item L<syntax|#syntax>

=head3 CÂ«ourÂ» define something in OUR:: scope
=item L<syntax|#syntax>

=head3 CÂ«anonÂ» define something without storing it in a scope
=item L<syntax|#syntax>

=head2 Differentoid

The Differentoid group contains the infix operators that return True if the compared elements
are different in a way, and False if they are considered equal in that
way.

=head3 CÂ«beforeÂ» generic less
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«<Â» numerically less
=item L<infix|#infix> L<numeric|#numeric> L<boolean|#boolean>

=head3 CÂ«ltÂ» alphabetically less
=item L<infix|#infix> L<string|#string> L<boolean|#boolean>

=head3 CÂ«<=Â» numerically less or equal
=item alternates: CÂ«â‰¤Â»
=item L<infix|#infix> L<numeric|#numeric> L<boolean|#boolean>

=head3 CÂ«leÂ» alphabetically less or equal
=item L<infix|#infix> L<string|#string> L<boolean|#boolean>

=head3 CÂ«!=Â» numeric inequality
=item alternates: CÂ«â‰ Â»
=item L<infix|#infix> L<numeric|#numeric> L<boolean|#boolean>

=head3 CÂ«neÂ» string inequality
=item L<infix|#infix> L<string|#string> L<boolean|#boolean>

=head3 CÂ«>=Â» numerically more or equal
=item L<infix|#infix> L<numeric|#numeric> L<boolean|#boolean>

=head3 CÂ«geÂ» alphabetically more or equal
=item L<infix|#infix> L<string|#string> L<boolean|#boolean>

=head3 CÂ«>Â» numerically more
=item L<infix|#infix> L<numeric|#numeric> L<boolean|#boolean>

=head3 CÂ«gtÂ» alphabetically more
=item L<infix|#infix> L<string|#string> L<boolean|#boolean>

=head3 CÂ«afterÂ» generic more
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«!(elem)Â» is not element in
=item alternates: CÂ«âˆ‰Â»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«!(cont)Â» does not contain element
=item alternates: CÂ«âˆŒÂ»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«!(<)Â» is not a strict quanthash subset
=item alternates: CÂ«âŠ„Â»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«!(<=)Â» is not a quanthash subset
=item alternates: CÂ«âŠˆÂ»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«!(==)Â» quanthash inequality
=item alternates: CÂ«â‰¢Â»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«!(>=)Â» is not a quanthash superset
=item alternates: CÂ«âŠ‰Â»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«!(>)Â» is not a strict quanthash superset
=item alternates: CÂ«âŠ…Â»
=item L<infix|#infix> L<boolean|#boolean>

=head2 Equalish

The Equalish group contains the infix operators that return C<True> if the compared elements
are considered equal in a way, and C<False> if they are considered different
in that way.

=head3 L<CÂ«~~Â» smart match|Performs a smart-match on the given arguments.  Technically, this is>
=item L<infix|#infix>

calling the C<.ACCEPTS> method on the right side, giving it the
left side as the positional argument.  Which usually results in a
C<Bool> value.

=head3 CÂ«eqvÂ» canonical equivalence
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«eqÂ» string equality
=item L<infix|#infix> L<string|#string> L<boolean|#boolean>

=head3 CÂ«==Â» numeric equality
=item L<infix|#infix> L<numeric|#numeric> L<boolean|#boolean>

=head3 CÂ«=~=Â» numeric almost equal
=item alternates: CÂ«â‰…Â»
=item L<infix|#infix> L<numeric|#numeric> L<boolean|#boolean>

=head3 CÂ«===Â» value identity
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«=:=Â» value identity without decontainerization
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«(elem)Â» is element in
=item alternates: CÂ«âˆˆÂ»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«(cont)Â» contains element
=item alternates: CÂ«âˆ‹Â»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«(<)Â» is strict quanthash subset
=item alternates: CÂ«âŠ‚Â»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«(<=)Â» is quanthash subset
=item alternates: CÂ«âŠ†Â»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«(==)Â» quanthash equality
=item alternates: CÂ«â‰¡Â»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«(>=)Â» is quanthash superset
=item alternates: CÂ«âŠ‡Â»
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«(>)Â» is strict quanthash superset
=item alternates: CÂ«âŠƒÂ»
=item L<infix|#infix> L<boolean|#boolean>

=head2 Expansive

The Expansive group contains the postfix operators that expand on numeric values.

=head3 L<CÂ«iÂ» numeric multiplication with the imaginary unit (âˆš-1)|https://docs.raku.org/type/Complex#postfix_i>
=item L<postfix|#postfix> L<numeric|#numeric>

C<4i> is the same as C<0+4i>.  Needs grouping for variables C<($a)i>
because otherwise the C<i> will be considered part of the variable
name.

=head3 L<CÂ«â¿Â» numeric literal integer exponentiation|https://docs.raku.org/routine/%2A%2A>
=item L<postfix|#postfix> L<numeric|#numeric>

So C<$aÂ²> is the same as C<$a ** 2>, etc.  Any of C<â°Â¹Â²Â³â´âµâ¶â·â¸â¹âºÂ¯Â¯> may
be used.

=head2 Feedoid

The Feedoid group contains the operators that provide an alternate syntax for creating
a sequence of operations, where the result of one such operation
become the argument(s) for the next operation.

=head3 L<CÂ«==>Â» feed left to right|https://docs.raku.org/language/operators#infix_==%3E>
=item L<infix|#infix>

CÂ«(1,2,3,4) ==> sum() ==> say()Â» as opposed to C<say sum (1,2,3,4)>
or C<(1,2,3,4).sum.say>.

=head3 L<CÂ«<==Â» feed right to left|https://docs.raku.org/language/operators#infix_%3C==>
=item L<infix|#infix>

CÂ«say() <== sum() <== (1,2,3,4)Â» as opposed to C<say sum (1,2,3,4)>
or C<(1,2,3,4).sum.say>.

=head2 Flippant

The Flippant group contains the operators that produce one or the other value, depending
on some condition.

=head3 CÂ«?? !!Â» ternary logic
=item L<syntax|#syntax>

=head3 CÂ«ffÂ» flip-flop inclusive
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«^ffÂ» flip-flop excluding start
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«ff^Â» flip-flop excluding end
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«^ff^Â» flip-flop exclusive
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«fffÂ» sed-like flip-flop inclusive
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«^fffÂ» sed-like flip-flop excluding start
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«fff^Â» sed-like flip-flop excluding end
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«^fff^Â» sed-like flip-flop exclusive
=item L<infix|#infix> L<macro|#macro>

=head2 Hyperoid

The Hyperoid group contains the operators that take the name of an infix operator and
repeatedly perform that operator on the provided argument list(s).

=head3 CÂ«>>op<<Â» produce operator results for equal lists
=item alternates: C<Â»opÂ« >
=item L<infix|#infix> L<syntax|#syntax>

=head3 CÂ«>>op>>Â» produce operator results, left side leading
=item alternates: C<Â»opÂ»>
=item L<infix|#infix> L<syntax|#syntax>

=head3 CÂ«<<op<<Â» produce operator results, right side leading
=item alternates: C<Â«opÂ«>
=item L<infix|#infix> L<syntax|#syntax>

=head3 CÂ«<<op>>Â» produce operator results, longest side leading
=item alternates: C<Â«opÂ»>
=item L<infix|#infix> L<syntax|#syntax>

=head3 L<CÂ«ZopÂ» produce operator result, shortest side leading|Default for `op` is `,`>
=item L<infix|#infix> L<syntax|#syntax>

=head3 L<CÂ«XopÂ» produce operator result for combinations|Default for `op` is `,`>
=item L<infix|#infix> L<syntax|#syntax>

=head2 IOoid

The IOoid group contains the functions that are available for input / output of data.

=head3 CÂ«getÂ» Read a line from C<C<$*STDIN>> / C<C<$*ARGFILES>>
=item L<sub|#sub> L<method|#method> L<string|#string>

=head3 CÂ«getcÂ» Read a character from C<C<$*STDIN>> / C<C<$*ARGFILES>>
=item L<sub|#sub> L<method|#method> L<string|#string>

=head3 CÂ«readÂ» Read bytes from an C<IO::Handle>
=item L<method|#method>

=head3 CÂ«writeÂ» Write bytes to an C<IO::Handle>
=item L<method|#method>

=head3 CÂ«slurpÂ» Read entire contents of C<IO::Path> / C<IO::Handle>
=item L<sub|#sub> L<method|#method>

=head3 CÂ«spurtÂ» Replace content of C<IO::Path> / C<IO::Handle> with argument
=item L<sub|#sub> L<method|#method>

=head2 Incremental

The Incremental group contains the infix operators for incrementing / decrementing (usually)
numeric values.

The atomic versions of C<--> and C<++> were implemented for 6.d.  They
can only be applied to atomic integers.

=head3 CÂ«++Â» pre-increment by 1
=item L<prefix|#prefix>

=head3 CÂ«âš›++Â» atomic pre-increment by 1
=item L<prefix|#prefix> L<numeric|#numeric>

=head3 CÂ«--Â» pre-decrement by 1
=item L<prefix|#prefix>

=head3 CÂ«âš›--Â» atomic pre-decrement by 1
=item L<prefix|#prefix> L<numeric|#numeric>

=head3 CÂ«++Â» post-increment by 1
=item L<postfix|#postfix>

=head3 CÂ«âš›++Â» atomic post-increment by 1
=item L<postfix|#postfix> L<numeric|#numeric>

=head3 CÂ«--Â» post-decrement by 1
=item L<postfix|#postfix>

=head3 CÂ«âš›--Â» atomic post-decrement by 1
=item L<postfix|#postfix> L<numeric|#numeric>

=head2 Junctive

The Junctive group contains the infix operators and the functions that produce C<Junction>
objects.

=head3 CÂ«&Â» junctive all
=item L<infix|#infix> L<junction|#junction>

=head3 CÂ«|Â» junctive any
=item L<infix|#infix> L<junction|#junction>

=head3 CÂ«^Â» junctive one
=item L<infix|#infix> L<junction|#junction>

=head3 CÂ«allÂ» junctive all
=item L<sub|#sub> L<method|#method> L<junction|#junction>

=head3 CÂ«anyÂ» junctive any
=item L<sub|#sub> L<method|#method> L<junction|#junction>

=head3 CÂ«oneÂ» junctive one
=item L<sub|#sub> L<method|#method> L<junction|#junction>

=head3 CÂ«noneÂ» junctive none
=item L<sub|#sub> L<method|#method> L<junction|#junction>

=head2 Mathematicals

The Mathematicals group contains the mathematical terms that are provided by the core.

=head3 CÂ«piÂ» The number Ï€ (3.1415...)
=item alternates: CÂ«Ï€Â»
=item L<term|#term> L<numeric|#numeric>

=head3 CÂ«tauÂ» The number Ï„ (6.2831...)
=item alternates: CÂ«Ï„Â»
=item L<term|#term> L<numeric|#numeric>

=head3 CÂ«eÂ» Euler's number (2.7182...)
=item alternates: CÂ«ğ‘’Â»
=item L<term|#term> L<numeric|#numeric>

=head3 CÂ«iÂ» The imaginary unit (âˆš-1)
=item L<term|#term> L<numeric|#numeric>

=head3 CÂ«InfÂ» Infinity
=item alternates: CÂ«âˆÂ»
=item L<term|#term> L<numeric|#numeric>

=head2 Metaoid

The Metaoid group contains the meta operators that take an infix operator and do something
special with its result or its arguments.

=head3 CÂ«op=Â» store result of infix operator on left side
=item L<infix|#infix> L<syntax|#syntax>

=head3 CÂ«RopÂ» produce result of infix operator with arguments reversed
=item L<infix|#infix> L<syntax|#syntax>

=head3 CÂ«!opÂ» negate result of iffy infix operator on arguments
=item L<infix|#infix> L<syntax|#syntax>

=head2 Methodic

The Methodic group contains the ways a method can be called on an object.

Dotted postfix operators must be followed by a method name or a subroutine
name prefixed with `&` (possibly fully qualified), a postfix operator, a
prefix operator within `:<>`, or one of the postcircumfixes `( )` `[ ]`
`{ }` `< >` `Â« Â»`.

=head3 CÂ«.methodÂ» method call
=item L<postfix|#postfix>

=head3 CÂ«. methodÂ» dotty infix method call
=item L<infix|#infix>

=head3 CÂ«.^methodÂ» meta-method call
=item L<postfix|#postfix>

=head3 CÂ«.?methodÂ» call method if any
=item L<postfix|#postfix>

=head3 CÂ«.*methodÂ» call all methods if any
=item L<postfix|#postfix>

=head3 CÂ«.+methodÂ» call all methods
=item L<postfix|#postfix>

=head3 CÂ«!methodÂ» private method call
=item L<postfix|#postfix>

=head3 CÂ«.=methodÂ» incovant mutating method call
=item L<postfix|#postfix>

=head2 Mixoid

The Mixoid group contains the functions that allow mixing in functionality into an existing
class or instantiation.

=head3 CÂ«doesÂ» mutating role mixin
=item L<infix|#infix>

=head3 CÂ«butÂ» cloning role mixin
=item L<infix|#infix>

=head2 Multiplicoid

The Multiplicoid group contains all infix operators that are related to multiplication in some
way.

=head3 CÂ«divÂ» integer divide
=item L<infix|#infix> L<integer|#integer>

=head3 CÂ«modÂ» integer modulus
=item L<infix|#infix> L<integer|#integer>

=head3 CÂ«gcdÂ» greatest common divisor
=item L<infix|#infix> L<integer|#integer>

=head3 CÂ«lcmÂ» lowest common multiple
=item L<infix|#infix> L<integer|#integer>

=head3 CÂ«*Â» multiply
=item alternates: CÂ«Ã—Â»
=item L<infix|#infix> L<numeric|#numeric>

=head3 CÂ«/Â» divide
=item alternates: CÂ«Ã·Â»
=item L<infix|#infix> L<numeric|#numeric>

=head3 CÂ«**Â» exponentiation
=item L<infix|#infix> L<numeric|#numeric>

=head3 CÂ«%Â» modulus
=item L<infix|#infix> L<numeric|#numeric>

=head3 CÂ«%%Â» is divisible
=item L<infix|#infix> L<boolean|#boolean>

=head3 CÂ«+<Â» integer shift left
=item L<infix|#infix> L<integer|#integer>

=head3 CÂ«+>Â» integer shift right
=item L<infix|#infix> L<integer|#integer>

=head2 Normaloid

The Normaloid group contains the operators that somehow normalize the given arguments into
something else, either in time or in value.

=head3 CÂ«+Â» numerify
=item L<prefix|#prefix> L<numeric|#numeric>

=head3 CÂ«+^Â» numeric complement
=item L<prefix|#prefix> L<numeric|#numeric>

=head3 CÂ«-Â» numeric negation
=item alternates: CÂ«âˆ’Â»
=item L<prefix|#prefix> L<numeric|#numeric>

=head3 CÂ«^Â» numeric from zero upto
=item L<prefix|#prefix> L<numeric|#numeric>

=head3 CÂ«~Â» stringify
=item L<prefix|#prefix> L<string|#string>

=head3 CÂ«?Â» boolify
=item L<prefix|#prefix> L<boolean|#boolean>

=head3 CÂ«soÂ» low precedence boolify
=item L<prefix|#prefix> L<boolean|#boolean>

=head3 CÂ«!Â» boolean negation
=item alternates: CÂ«?^Â»
=item L<prefix|#prefix> L<boolean|#boolean>

=head3 CÂ«notÂ» low precedence boolean negation
=item L<prefix|#prefix> L<boolean|#boolean>

=head3 CÂ«//Â» is defined
=item L<prefix|#prefix> L<boolean|#boolean>

=head3 L<CÂ«|Â» flatten args, slip iterable|https://docs.raku.org/syntax/%7C>
=item L<prefix|#prefix>

The meaning of prefix `|` was expanded in 6.c to be beyond the use within
signatures, to mean converting any iterable to a `Slip` (a special type of
`list` that will always be iterated).

=head3 L<CÂ«âš›Â» atomic integer access|https://docs.raku.org/routine/âš›>
=item L<prefix|#prefix>

Ensures the latest update of a value in the target is produced in
multi-threaded situations.

=head2 Orderoid

The Orderoid group contains the infix operators that return an C<Order> value.

=head3 CÂ«cmpÂ» equivalence order comparison
=item L<infix|#infix> L<order|#order>

=head3 CÂ«<=>Â» numerical order comparison
=item L<infix|#infix> L<order|#order>

=head3 CÂ«legÂ» string order comparison
=item L<infix|#infix> L<order|#order>

=head2 Quantoid

The Quantoid group contains the functions that return a C<QuantHash> (a C<Set>, C<SetHash>,
C<Bag>, C<BagHash>, C<Mix> or C<MixHash> given any set or arguments.

=head3 CÂ«âˆ…Â» empty Set
=item L<term|#term> L<quanthash|#quanthash>

=head3 CÂ«(|)Â» quanthash union
=item alternates: CÂ«âˆªÂ»
=item L<infix|#infix> L<quanthash|#quanthash>

=head3 CÂ«(+)Â» quanthash addition
=item alternates: CÂ«âŠÂ»
=item L<infix|#infix> L<quanthash|#quanthash>

=head3 CÂ«(.)Â» quanthash multiplication
=item alternates: CÂ«âŠÂ»
=item L<infix|#infix> L<quanthash|#quanthash>

=head3 CÂ«(-)Â» quanthash difference
=item alternates: CÂ«âˆ–Â»
=item L<infix|#infix> L<quanthash|#quanthash>

=head3 CÂ«(^)Â» quanthash symmetric difference
=item alternates: CÂ«âŠ–Â»
=item L<infix|#infix> L<quanthash|#quanthash>

=head2 Rangoid

The Rangoid group contains the infix operators that produce a C<Range>.

=head3 CÂ«..Â» range inclusive
=item L<infix|#infix> L<range|#range>

=head3 CÂ«^..Â» range excluding start
=item L<infix|#infix> L<range|#range>

=head3 CÂ«..^Â» range excluding end
=item L<infix|#infix> L<range|#range>

=head3 CÂ«^..^Â» range exclusive
=item L<infix|#infix> L<range|#range>

=head3 CÂ«minmaxÂ» range including min and max value
=item L<infix|#infix> L<range|#range>

=head2 Reductoid

The Reductoid group contains the functions that reduce a given set of arguments into
a single value (or produces the steps to produce that value).

=head3 CÂ«minÂ» reduce values to smallest value
=item L<infix|#infix> L<sub|#sub> L<method|#method>

=head3 CÂ«maxÂ» reduce values to largest value
=item L<infix|#infix> L<sub|#sub> L<method|#method>

=head3 CÂ«[op]Â» reduce using given infix operator
=item L<prefix|#prefix> L<syntax|#syntax>

=head3 CÂ«[\op]Â» produce steps of reduction using given infix operator
=item L<prefix|#prefix> L<syntax|#syntax>

=head2 Replicant

The Replicant group contains the infix operators that reproduce the left value repeatedly.

=head3 CÂ«xÂ» string repetition
=item L<infix|#infix> L<string|#string>

=head3 CÂ«xxÂ» item repetition
=item L<infix|#infix> L<thunky|#thunky>

=head2 Sequoid

The Sequoid group contains the infix operators that create a smart sequence (one that
inspect the arguments and interpretes special, almost magic, meaning).

=head3 CÂ«...Â» smart sequence inclusive
=item L<infix|#infix>

=head3 CÂ«^...Â» smart sequence excluding start
=item L<infix|#infix>

=head3 CÂ«...^Â» smart sequence excluding end
=item L<infix|#infix>

=head3 CÂ«^...^Â» smart sequence exclusive
=item L<infix|#infix>

=head2 Shortoid

The Shortoid group contains the infixish macros that exhibit short-cicuiting behaviour,
where the right hand side will B<not> be evaluated if a certain condition
on the left hand side was met.

=head3 CÂ«&&Â» high precedence logical AND
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«andÂ» low precedence logical AND
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«||Â» high precedence logical OR
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«orÂ» low precedence logical OR
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«^^Â» high precedence logical XOR
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«xorÂ» low precedence logical XOR
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«//Â» high precedence is defined OR
=item L<infix|#infix> L<macro|#macro>

=head3 CÂ«notandthenÂ» Empty if first defined, else last
=item L<infix|#infix> L<macro|#macro> L<topic|#topic>

=head2 Stuboid

The Stuboid group contains the functionality that can be used to indicate that code
will need to be added at a later time (e.g. in the development cycle
of the code), or at compilation time by mixing in a role.

=head3 CÂ«???Â» warn about stub code executed
=item L<term|#term> L<macro|#macro>

=head3 CÂ«...Â» fail with stub code executed error
=item L<term|#term> L<macro|#macro>

=head3 CÂ«!!!Â» die with stub code executed error
=item L<term|#term> L<macro|#macro>

=head2 Talkoid

The Talkoid group contains the functions that are generally used to display messages
to a user.

=head3 CÂ«printÂ» stringify argument(s), write to C<$*STDOUT>
=item L<sub|#sub> L<method|#method> L<string|#string>

=head3 CÂ«sayÂ» create gist of argument(s), add newline, write to C<$*STDOUT>
=item L<sub|#sub> L<method|#method> L<string|#string>

=head3 CÂ«putÂ» stringify argument(s), add newline, write to C<$*STDOUT>
=item L<sub|#sub> L<method|#method> L<string|#string>

=head3 CÂ«noteÂ» create gist of argument(s), add newline, write to C<$*STDERR>
=item L<sub|#sub> L<method|#method> L<string|#string>

=head2 Termoid

The Termoid group contains the functions that act as a term, but do B<not> produce a
constant value.

=head3 CÂ«selfÂ» invocant in method
=item L<term|#term>

=head3 CÂ«randÂ» pseudo-random Num in range 
=item L<term|#term>

=head3 CÂ«nowÂ» C<Instant> of current time
=item L<term|#term>

=head3 CÂ«timeÂ» POSIX time in seconds
=item L<term|#term>

=head3 CÂ«nanoÂ» POSIX time in nano seconds
=item L<term|#term>

=head2 Throwoid

The Throwoid group contains the functions that somehow interrupt the normal flow of execution
either very noticeably, or very much under the hood.

=head3 CÂ«dieÂ» halt execution, or be caught by C<CATCH>
=item L<sub|#sub> L<interrupt|#interrupt>

=head3 CÂ«warnÂ» show error message, or be caught by C<CONTROL>
=item L<sub|#sub>

=head3 CÂ«failÂ» return from Routine with Failure, or be caught by C<CATCH>
=item L<sub|#sub> L<interrupt|#interrupt>

=head3 CÂ«returnÂ» return from Routine with given value, or be caught by C<CONTROL>
=item L<sub|#sub> L<method|#method> L<interrupt|#interrupt>

=head3 CÂ«nextÂ» proceed with next iteration, or be caught by C<CONTROL>
=item L<sub|#sub> L<interrupt|#interrupt>

=head3 CÂ«redoÂ» restart current iteration, or be caught by C<CONTROL>
=item L<sub|#sub> L<interrupt|#interrupt>

=head3 CÂ«lastÂ» stop iterating, or be caught by C<CONTROL>
=item L<sub|#sub> L<interrupt|#interrupt>

=head3 CÂ«proceedÂ» continue with next when/default, or be caught by C<CONTROL>
=item L<sub|#sub> L<interrupt|#interrupt>

=head3 CÂ«succeedÂ» continue after last when/default, or be caught by C<CONTROL>
=item L<sub|#sub> L<interrupt|#interrupt>

=head3 CÂ«doneÂ» call "done" callback on taps, or be caught by C<CONTROL>
=item L<sub|#sub> L<interrupt|#interrupt>

=head3 CÂ«emitÂ» emit given value to active supply, or be caught by C<CONTROL>
=item L<sub|#sub> L<method|#method>

=head3 CÂ«takeÂ» produce a value in a C<gather> sequence, or be caught by C<CONTROL>
=item L<sub|#sub> L<method|#method>

=head2 Topicoid

The Topicoid group contains the functions that topicalize (set C<$_>) in some situations.

=head3 CÂ«givenÂ» topicalize argument for scope
=item L<syntax|#syntax> L<topic|#topic>

=head3 CÂ«whenÂ» if smartmatched topicalize argument for scope
=item L<syntax|#syntax>

=head3 CÂ«andthen topicÂ» topicalize left for right thunk
=item L<infix|#infix> L<thunky|#thunky>

=head3 CÂ«orelse topicÂ» low precedence if defined OR, topicalizing left for right thunk
=item L<infix|#infix> L<thunky|#thunky>

=comment PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE

=head1 RESOURCE FILES

This distribution keeps all of the text files as resources, to be read when
they are needed (as opposed to keeping them all in the binary).

The C<resources> directory contains a C<groups> directory that contains all
of the information for each group in a separat file.

=head2 Group file format

The format of the group file is very simple line based.

All entries are separated by an empty line.  The first line contains the
names of the element separated by the string C< | > (space, pipe, space).
There must be at least one name.  The first name becomes the C<name> of
the element, the others become C<aliases>.

The second line contains theo tags as space separated words.  There must
be at least a single tag.

The third line contains the tagline of the element.

The fourth line (if not empty) contains the URL for more information,

Any other lines until an empty line, contains the description of the
element.  It may contain RakuDoc markup codes.

If the first line is empty, then the rest of the file contains the
description of the group (so you can recognize the description as the
text after the first 2 empty lines).  It may contain RakuDoc markup
codes.  If there are no 2 empty lines, then there is B<no> description
(yet) for the group.

=head1 AUTHOR

Elizabeth Mattijsen <liz@raku.rocks>

Source can be located at: https://github.com/lizmat/Raku-Elements .
Comments and Pull Requests are welcome.

If you like this module, or what Iâ€™m doing more generally, committing to a
L<small sponsorship|https://github.com/sponsors/lizmat/>  would mean a great
deal to me!

=head1 COPYRIGHT AND LICENSE

Copyright 2025 Elizabeth Mattijsen

This library is free software; you can redistribute it and/or modify it under the Artistic License 2.0.

=end pod

# vim: expandtab shiftwidth=4
